import requests
import json
import threading
import time
import os
import flag
import math
from datetime import datetime
from flask import Flask, render_template, request
import pycountry

app = Flask(__name__)
data_file = "dataransom.json"
data = []

country_flags = {
    "AF": 'ğŸ‡¦ğŸ‡«',
    "AX": 'ğŸ‡¦ğŸ‡½',
    "AL": 'ğŸ‡¦ğŸ‡±',
    "DZ": 'ğŸ‡©ğŸ‡¿',
    "AS": 'ğŸ‡¦ğŸ‡¸',
    "AD": 'ğŸ‡¦ğŸ‡©',
    "AO": 'ğŸ‡¦ğŸ‡´',
    "AI": 'ğŸ‡¦ğŸ‡®',
    "AQ": 'ğŸ‡¦ğŸ‡¶',
    "AG": 'ğŸ‡¦ğŸ‡¬',
    "AR": 'ğŸ‡¦ğŸ‡·',
    "AM": 'ğŸ‡¦ğŸ‡²',
    "AW": 'ğŸ‡¦ğŸ‡¼',
    "AU": 'ğŸ‡¦ğŸ‡º',
    "AT": 'ğŸ‡¦ğŸ‡¹',
    "AZ": 'ğŸ‡¦ğŸ‡¿',
    "BS": 'ğŸ‡§ğŸ‡¸',
    "BH": 'ğŸ‡§ğŸ‡­',
    "BD": 'ğŸ‡§ğŸ‡©',
    "BB": 'ğŸ‡§ğŸ‡§',
    "BY": 'ğŸ‡§ğŸ‡¾',
    "BE": 'ğŸ‡§ğŸ‡ª',
    "BZ": 'ğŸ‡§ğŸ‡¿',
    "BJ": 'ğŸ‡§ğŸ‡¯',
    "BM": 'ğŸ‡§ğŸ‡²',
    "BT": 'ğŸ‡§ğŸ‡¹',
    "BO": 'ğŸ‡§ğŸ‡´',
    "BA": 'ğŸ‡§ğŸ‡¦',
    "BW": 'ğŸ‡§ğŸ‡¼',
    "BR": 'ğŸ‡§ğŸ‡·',
    "IO": 'ğŸ‡®ğŸ‡´',
    "VG": 'ğŸ‡»ğŸ‡¬',
    "BN": 'ğŸ‡§ğŸ‡³',
    "BG": 'ğŸ‡§ğŸ‡¬',
    "BF": 'ğŸ‡§ğŸ‡«',
    "BI": 'ğŸ‡§ğŸ‡®',
    "KH": 'ğŸ‡°ğŸ‡­',
    "CM": 'ğŸ‡¨ğŸ‡²',
    "CA": 'ğŸ‡¨ğŸ‡¦',
    "CV": 'ğŸ‡¨ğŸ‡»',
    "BQ": 'ğŸ‡§ğŸ‡¶',
    "KY": 'ğŸ‡°ğŸ‡¾',
    "CF": 'ğŸ‡¨ğŸ‡«',
    "TD": 'ğŸ‡¹ğŸ‡©',
    "CL": 'ğŸ‡¨ğŸ‡±',
    "CN": 'ğŸ‡¨ğŸ‡³',
    "CX": 'ğŸ‡¨ğŸ‡½',
    "CC": 'ğŸ‡¨ğŸ‡¨',
    "CO": 'ğŸ‡¨ğŸ‡´',
    "KM": 'ğŸ‡°ğŸ‡²',
    "CG": 'ğŸ‡¨ğŸ‡¬',
    "CK": 'ğŸ‡¨ğŸ‡°',
    "CR": 'ğŸ‡¨ğŸ‡·',
    "HR": 'ğŸ‡­ğŸ‡·',
    "CU": 'ğŸ‡¨ğŸ‡º',
    "CW": 'ğŸ‡¨ğŸ‡¼',
    "CY": 'ğŸ‡¨ğŸ‡¾',
    "CZ": 'ğŸ‡¨ğŸ‡¿',
    "CD": 'ğŸ‡¨ğŸ‡©',
    "DK": 'ğŸ‡©ğŸ‡°',
    "DJ": 'ğŸ‡©ğŸ‡¯',
    "DM": 'ğŸ‡©ğŸ‡²',
    "DO": 'ğŸ‡©ğŸ‡´',
    "EC": 'ğŸ‡ªğŸ‡¨',
    "EG": 'ğŸ‡ªğŸ‡¬',
    "SV": 'ğŸ‡¸ğŸ‡»',
    "GQ": 'ğŸ‡¬ğŸ‡¶',
    "ER": 'ğŸ‡ªğŸ‡·',
    "EE": 'ğŸ‡ªğŸ‡ª',
    "ET": 'ğŸ‡ªğŸ‡¹',
    "FK": 'ğŸ‡«ğŸ‡°',
    "FO": 'ğŸ‡«ğŸ‡´',
    "FM": 'ğŸ‡«ğŸ‡²',
    "FJ": 'ğŸ‡«ğŸ‡¯',
    "FI": 'ğŸ‡«ğŸ‡®',
    "FR": 'ğŸ‡«ğŸ‡·',
    "GF": 'ğŸ‡¬ğŸ‡«',
    "PF": 'ğŸ‡µğŸ‡«',
    "TF": 'ğŸ‡¹ğŸ‡«',
    "GA": 'ğŸ‡¬ğŸ‡¦',
    "GM": 'ğŸ‡¬ğŸ‡²',
    "GE": 'ğŸ‡¬ğŸ‡ª',
    "DE": 'ğŸ‡©ğŸ‡ª',
    "GH": 'ğŸ‡¬ğŸ‡­',
    "GI": 'ğŸ‡¬ğŸ‡®',
    "GR": 'ğŸ‡¬ğŸ‡·',
    "GL": 'ğŸ‡¬ğŸ‡±',
    "GD": 'ğŸ‡¬ğŸ‡©',
    "GP": 'ğŸ‡¬ğŸ‡µ',
    "GU": 'ğŸ‡¬ğŸ‡º',
    "GT": 'ğŸ‡¬ğŸ‡¹',
    "GN": 'ğŸ‡¬ğŸ‡³',
    "GW": 'ğŸ‡¬ğŸ‡¼',
    "GY": 'ğŸ‡¬ğŸ‡¾',
    "HT": 'ğŸ‡­ğŸ‡¹',
    "HN": 'ğŸ‡­ğŸ‡³',
    "HK": 'ğŸ‡­ğŸ‡°',
    "HU": 'ğŸ‡­ğŸ‡º',
    "IS": 'ğŸ‡®ğŸ‡¸',
    "IN": 'ğŸ‡®ğŸ‡³',
    "ID": 'ğŸ‡®ğŸ‡©',
    "IR": 'ğŸ‡®ğŸ‡·',
    "IQ": 'ğŸ‡®ğŸ‡¶',
    "IE": 'ğŸ‡®ğŸ‡ª',
    "IM": 'ğŸ‡®ğŸ‡²',
    "IL": 'ğŸ‡®ğŸ‡±',
    "IT": 'ğŸ‡®ğŸ‡¹',
    "CI": 'ğŸ‡¨ğŸ‡®',
    "JM": 'ğŸ‡¯ğŸ‡²',
    "JP": 'ğŸ‡¯ğŸ‡µ',
    "JE": 'ğŸ‡¯ğŸ‡ª',
    "JO": 'ğŸ‡¯ğŸ‡´',
    "KZ": 'ğŸ‡°ğŸ‡¿',
    "KE": 'ğŸ‡°ğŸ‡ª',
    "KI": 'ğŸ‡°ğŸ‡®',
    "XK": 'ğŸ‡½ğŸ‡°',
    "KW": 'ğŸ‡°ğŸ‡¼',
    "KG": 'ğŸ‡°ğŸ‡¬',
    "LA": 'ğŸ‡±ğŸ‡¦',
    "LV": 'ğŸ‡±ğŸ‡»',
    "LB": 'ğŸ‡±ğŸ‡§',
    "LS": 'ğŸ‡±ğŸ‡¸',
    "LR": 'ğŸ‡±ğŸ‡·',
    "LY": 'ğŸ‡±ğŸ‡¾',
    "LI": 'ğŸ‡±ğŸ‡®',
    "LT": 'ğŸ‡±ğŸ‡¹',
    "LU": 'ğŸ‡±ğŸ‡º',
    "MO": 'ğŸ‡²ğŸ‡´',
    "MK": 'ğŸ‡²ğŸ‡°',
    "MG": 'ğŸ‡²ğŸ‡¬',
    "MW": 'ğŸ‡²ğŸ‡¼',
    "MY": 'ğŸ‡²ğŸ‡¾',
    "MV": 'ğŸ‡²ğŸ‡»',
    "ML": 'ğŸ‡²ğŸ‡±',
    "MT": 'ğŸ‡²ğŸ‡¹',
    "MH": 'ğŸ‡²ğŸ‡­',
    "MQ": 'ğŸ‡²ğŸ‡¶',
    "MR": 'ğŸ‡²ğŸ‡·',
    "MU": 'ğŸ‡²ğŸ‡º',
    "YT": 'ğŸ‡¾ğŸ‡¹',
    "MX": 'ğŸ‡²ğŸ‡½',
    "MD": 'ğŸ‡²ğŸ‡©',
    "MC": 'ğŸ‡²ğŸ‡¨',
    "MN": 'ğŸ‡²ğŸ‡³',
    "ME": 'ğŸ‡²ğŸ‡ª',
    "MS": 'ğŸ‡²ğŸ‡¸',
    "MA": 'ğŸ‡²ğŸ‡¦',
    "MZ": 'ğŸ‡²ğŸ‡¿',
    "MM": 'ğŸ‡²ğŸ‡²',
    "NA": 'ğŸ‡³ğŸ‡¦',
    "NR": 'ğŸ‡³ğŸ‡·',
    "NP": 'ğŸ‡³ğŸ‡µ',
    "NL": 'ğŸ‡³ğŸ‡±',
    "NC": 'ğŸ‡³ğŸ‡¨',
    "NZ": 'ğŸ‡³ğŸ‡¿',
    "NI": 'ğŸ‡³ğŸ‡®',
    "NE": 'ğŸ‡³ğŸ‡ª',
    "NG": 'ğŸ‡³ğŸ‡¬',
    "NU": 'ğŸ‡³ğŸ‡º',
    "NF": 'ğŸ‡³ğŸ‡«',
    "KP": 'ğŸ‡°ğŸ‡µ',
    "MP": 'ğŸ‡²ğŸ‡µ',
    "NO": 'ğŸ‡³ğŸ‡´',
    "OM": 'ğŸ‡´ğŸ‡²',
    "PK": 'ğŸ‡µğŸ‡°',
    "PW": 'ğŸ‡µğŸ‡¼',
    "PS": 'ğŸ‡µğŸ‡¸',
    "PA": 'ğŸ‡µğŸ‡¦',
    "PG": 'ğŸ‡µğŸ‡¬',
    "PY": 'ğŸ‡µğŸ‡¾',
    "PE": 'ğŸ‡µğŸ‡ª',
    "PH": 'ğŸ‡µğŸ‡­',
    "PN": 'ğŸ‡µğŸ‡³',
    "PL": 'ğŸ‡µğŸ‡±',
    "PT": 'ğŸ‡µğŸ‡¹',
    "PR": 'ğŸ‡µğŸ‡·',
    "QA": 'ğŸ‡¶ğŸ‡¦',
    "RE": 'ğŸ‡·ğŸ‡ª',
    "RO": 'ğŸ‡·ğŸ‡´',
    "RU": 'ğŸ‡·ğŸ‡º',
    "RW": 'ğŸ‡·ğŸ‡¼',
    "SH": 'ğŸ‡¸ğŸ‡­',
    "KN": 'ğŸ‡°ğŸ‡³',
    "LC": 'ğŸ‡±ğŸ‡¨',
    "PM": 'ğŸ‡µğŸ‡²',
    "VC": 'ğŸ‡»ğŸ‡¨',
    "WS": 'ğŸ‡¼ğŸ‡¸',
    "SM": 'ğŸ‡¸ğŸ‡²',
    "ST": 'ğŸ‡¸ğŸ‡¹',
    "SA": 'ğŸ‡¸ğŸ‡¦',
    "SN": 'ğŸ‡¸ğŸ‡³',
    "RS": 'ğŸ‡·ğŸ‡¸',
    "SC": 'ğŸ‡¸ğŸ‡¨',
    "SL": 'ğŸ‡¸ğŸ‡±',
    "SG": 'ğŸ‡¸ğŸ‡¬',
    "SX": 'ğŸ‡¸ğŸ‡½',
    "SK": 'ğŸ‡¸ğŸ‡°',
    "SI": 'ğŸ‡¸ğŸ‡®',
    "SB": 'ğŸ‡¸ğŸ‡§',
    "SO": 'ğŸ‡¸ğŸ‡´',
    "ZA": 'ğŸ‡¿ğŸ‡¦',
    "GS": 'ğŸ‡¬ğŸ‡¸',
    "KR": 'ğŸ‡°ğŸ‡·',
    "SS": 'ğŸ‡¸ğŸ‡¸',
    "ES": 'ğŸ‡ªğŸ‡¸',
    "LK": 'ğŸ‡±ğŸ‡°',
    "SD": 'ğŸ‡¸ğŸ‡©',
    "SR": 'ğŸ‡¸ğŸ‡·',
    "SJ": 'ğŸ‡¸ğŸ‡¯',
    "SZ": 'ğŸ‡¸ğŸ‡¿',
    "SE": 'ğŸ‡¸ğŸ‡ª',
    "CH": 'ğŸ‡¨ğŸ‡­',
    "SY": 'ğŸ‡¸ğŸ‡¾',
    "TW": 'ğŸ‡¹ğŸ‡¼',
    "TJ": 'ğŸ‡¹ğŸ‡¯',
    "TZ": 'ğŸ‡¹ğŸ‡¿',
    "TH": 'ğŸ‡¹ğŸ‡­',
    "TL": 'ğŸ‡¹ğŸ‡±',
    "TG": 'ğŸ‡¹ğŸ‡¬',
    "TK": 'ğŸ‡¹ğŸ‡°',
    "TO": 'ğŸ‡¹ğŸ‡´',
    "TT": 'ğŸ‡¹ğŸ‡¹',
    "TN": 'ğŸ‡¹ğŸ‡³',
    "TR": 'ğŸ‡¹ğŸ‡·',
    "TM": 'ğŸ‡¹ğŸ‡²',
    "TC": 'ğŸ‡¹ğŸ‡¨',
    "TV": 'ğŸ‡¹ğŸ‡»',
    "UG": 'ğŸ‡ºğŸ‡¬',
    "UA": 'ğŸ‡ºğŸ‡¦',
    "AE": 'ğŸ‡¦ğŸ‡ª',
    "GB": 'ğŸ‡¬ğŸ‡§',
    "US": 'ğŸ‡ºğŸ‡¸',
    "UM": 'ğŸ‡ºğŸ‡²',
    "VI": 'ğŸ‡»ğŸ‡®',
    "UY": 'ğŸ‡ºğŸ‡¾',
    "UZ": 'ğŸ‡ºğŸ‡¿',
    "VU": 'ğŸ‡»ğŸ‡º',
    "VA": 'ğŸ‡»ğŸ‡¦',
    "VE": 'ğŸ‡»ğŸ‡ª',
    "VN": 'ğŸ‡»ğŸ‡³',
    "WF": 'ğŸ‡¼ğŸ‡«',
    "EH": 'ğŸ‡ªğŸ‡­',
    "YE": 'ğŸ‡¾ğŸ‡ª',
    "ZM": 'ğŸ‡¿ğŸ‡²',
    "ZW": 'ğŸ‡¿ğŸ‡¼',
}

def update_groups_json():
    # Descargar el archivo JSON desde la URL
    try:
        response = requests.get("https://data.ransomware.live/groups.json")
        response.raise_for_status()  # Asegurarse de que la solicitud fue exitosa
        new_data = response.json()
    except requests.RequestException as e:
        print(f"Error al descargar el JSON: {e}")
        return 

    # Cargar los datos desde dataransom.json
    try:
        with open("dataransom.json", "r", encoding='utf-8') as f:
            sources_data = json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        sources_data = []

    # Crear un diccionario para mapear group_name a una lista de posts
    group_posts = {}
    for item in sources_data:
        group_name = item.get('group_name', '').lower()
        if group_name:
            post = {
                'name': item.get('post_title', ''),
                'discovered': item.get('discovered', ''),
                'country': item.get('country', ''),
                'description': item.get('description', '')
            }
            group_posts.setdefault(group_name, []).append(post)

    # Leer el archivo groups.json si existe, de lo contrario usar una lista vacÃ­a
    if os.path.exists('groups.json'):
        with open('groups.json', 'r', encoding='utf-8') as file:
            existing_data = json.load(file)
    else:
        existing_data = []

    # Crear un diccionario de grupos existentes para facilitar la actualizaciÃ³n
    existing_groups = {entry['name'].lower(): entry for entry in existing_data}

    # Procesar los nuevos datos y actualizar o aÃ±adir grupos
    for item in new_data:
        name = item.get('name', '')
        lower_name = name.lower()
        locations = item.get('locations', [])

        # Obtener ubicaciones existentes o inicializar una lista vacÃ­a
        existing_locations = existing_groups.get(lower_name, {}).get('locations', [])

        # Crear un conjunto de enlaces existentes para evitar duplicados
        existing_links = {loc['Source Links'] for loc in existing_locations}

        # Filtrar y preparar las nuevas ubicaciones
        new_locations = [
            {'Source Links': loc.get('fqdn', '')}
            for loc in locations
            if loc.get('fqdn', '') and loc.get('fqdn', '') not in existing_links
        ]

        # Combinar ubicaciones existentes con nuevas
        combined_locations = existing_locations + new_locations

        # Obtener posts para este grupo
        posts = group_posts.get(lower_name, [])

        # Si el grupo ya existe, combinar los posts existentes con los nuevos
        existing_posts = existing_groups.get(lower_name, {}).get('posts', [])
        combined_posts = existing_posts + posts

        # Eliminar duplicados en posts basados en 'post_title'
        unique_posts = {post['name']: post for post in combined_posts}.values()

        # Actualizar o crear el grupo en existing_groups
        existing_groups[lower_name] = {
            'name': name,
            'locations': combined_locations,
            'targets': list(unique_posts)
        }

    # Convertir el diccionario de grupos en una lista
    updated_data = list(existing_groups.values())

    # Guardar los datos actualizados en groups.json
    with open('groups.json', 'w', encoding='utf-8') as file:
        json.dump(updated_data, file, indent=4, ensure_ascii=False)
    print("Archivo groups.json actualizado exitosamente.")



def fetch_and_update_data():
    """Fetch new data from the API and update the local file with the latest 200 entries."""
    global data

    try:
        response = requests.get("https://data.ransomware.live/posts.json")
        response.raise_for_status()
        new_data = response.json()

        # Load existing data
        if os.path.exists(data_file):
            with open(data_file, "r") as f:
                existing_data = json.load(f)
        else:
            existing_data = []

        # Crear un diccionario de registros existentes con la clave Ãºnica como llave
        existing_records = {
            (
                item.get("post_url") or '',
                item.get("post_title") or '',
                item.get("group_name") or ''
            ): item
            for item in existing_data
        }

        # Procesar nuevas entradas
        for item in new_data:
            key = (
                item.get("post_url") or '',
                item.get("post_title") or '',
                item.get("group_name") or ''
            )

            if key in existing_records:
                # Actualizar el registro existente con los nuevos datos
                existing_record = existing_records[key]
                # Actualizar todos los campos del registro existente con los nuevos valores
                for field, value in item.items():
                    existing_record[field] = value
            else:
                # Asignar un nuevo ID y agregar la nueva entrada
                item["id"] = len(existing_data) + 1
                existing_data.append(item)
                existing_records[key] = item  # Agregar al diccionario de registros existentes

        # Guardar los datos actualizados
        with open(data_file, "w") as f:
            json.dump(existing_data, f, indent=4)
        print(f"Data updated. Total entries: {len(existing_data)}.")

        data = existing_data
        
        # Update the latest 200 entries file
        latest_data = sorted(data, key=lambda x: datetime.strptime(x["discovered"], "%Y-%m-%d %H:%M:%S.%f"), reverse=True)[:200]
        with open("latest_200.json", "w") as f:
            json.dump(latest_data, f, indent=4)

    except Exception as e:
        print(f"An error occurred: {e}")


def schedule_data_fetching():
    while True:
        fetch_and_update_data()
        update_groups_json()
        time.sleep(3600)  # Fetch data every hour


def get_country_name(country_code):
    country = pycountry.countries.get(alpha_2=country_code.upper())
    return country.name if country else country_code

@app.route('/')
def index():
    global data
    try:
        with open("latest_200.json", "r") as f:
            data = json.load(f)
            # Convertir las cadenas de fecha a objetos datetime para ordenarlas
            for item in data:
                item["discovered"] = datetime.strptime(item["discovered"], "%Y-%m-%d %H:%M:%S.%f")
            data = sorted(data, key=lambda x: x["discovered"], reverse=True)
    except (FileNotFoundError, json.JSONDecodeError):
        data = []

    # Convertir los cÃ³digos de paÃ­s a emojis de bandera
    for item in data:
        country_code = item.get("country")
        if country_code:
            item["country_flag"] = country_flags.get(country_code, '')  # Usa el diccionario para obtener la bandera
        else:
            item["country_flag"] = ''



    group_filter = request.args.get('group-filter', '')
    country_filter = request.args.get('country-filter', '')
    discovered_order = request.args.get('discovered-order', 'desc')  # por defecto descendente

    # Filtrar los datos
    filtered_data = data
    if group_filter:
        filtered_data = [item for item in filtered_data if item['group_name'] == group_filter]
    if country_filter:
        filtered_data = [item for item in filtered_data if item['country'] == country_filter]

    # Ordenar los datos
    if discovered_order == 'asc':
        filtered_data.sort(key=lambda x: x['discovered'])
    else:
        filtered_data.sort(key=lambda x: x['discovered'], reverse=True)

    # Obtener listas Ãºnicas de grupos y paÃ­ses para los dropdowns
    groups = sorted(set(item['group_name'] for item in data))
    countries = sorted(set(item['country'] for item in data))

    return render_template("index.html", data=filtered_data, groups=groups, countries=countries, get_country_name=get_country_name)


@app.route('/all-victims')
def all_victims():
    global data
    try:
        with open("dataransom.json", "r") as f:
            data = json.load(f)
            # Convertir las cadenas de fecha a objetos datetime para ordenarlas
            for item in data:
                item["discovered"] = datetime.strptime(item["discovered"], "%Y-%m-%d %H:%M:%S.%f")
            data = sorted(data, key=lambda x: x["discovered"], reverse=True)
    except (FileNotFoundError, json.JSONDecodeError):
        data = []

    # Convertir los cÃ³digos de paÃ­s a emojis de bandera
    for item in data:
        country_code = item.get("country")
        if country_code:
            item["country_flag"] = country_flags.get(country_code, '')  # Usa el diccionario para obtener la bandera
        else:
            item["country_flag"] = ''


    group_filter = request.args.get('group-filter', '')
    country_filter = request.args.get('country-filter', '')
    discovered_order = request.args.get('discovered-order', 'desc')  # por defecto descendente

    # Filtrar los datos
    filtered_data = data
    if group_filter:
        filtered_data = [item for item in filtered_data if item['group_name'] == group_filter]
    if country_filter:
        filtered_data = [item for item in filtered_data if item['country'] == country_filter]

    # Ordenar los datos
    if discovered_order == 'asc':
        filtered_data.sort(key=lambda x: x['discovered'])
    else:
        filtered_data.sort(key=lambda x: x['discovered'], reverse=True)

    # PaginaciÃ³n
    page = request.args.get('page', 1, type=int)
    per_page = 500  # NÃºmero mÃ¡ximo de elementos por pÃ¡gina
    total_items = len(filtered_data)
    total_pages = math.ceil(total_items / per_page)
    start = (page - 1) * per_page
    end = start + per_page
    page_data = filtered_data[start:end]

    # Obtener listas Ãºnicas de grupos y paÃ­ses para los dropdowns
    groups = sorted(set(item['group_name'] for item in data))
    countries = sorted(set(item['country'] for item in data))

    return render_template("all_victims.html", data=page_data, page=page, total_pages=total_pages, groups=groups, countries=countries, get_country_name=get_country_name, 
        max=max, min=min, range=range)

# Nueva ruta para mostrar la lista de grupos
@app.route('/groups')
def groups():
    try:
        with open("groups.json", "r") as f:
            groups_data = json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        groups_data = []

    # Pasar solo los nombres de los grupos a la plantilla
    return render_template("groups.html", groups=groups_data)


# Nueva ruta para mostrar la lista de grupos
@app.route('/Breaches')
def Breaches():

    return render_template("Breaches.html")

# Nueva ruta para mostrar la lista de grupos
@app.route('/disclaimer')
def Disclaimer():

    return render_template("Disclaimer.html")

# Nueva ruta para mostrar la lista de grupos
@app.route('/leads')
def Leads():

    return render_template("Leads.html")

# Nueva ruta para mostrar la lista de grupos
@app.route('/stealer')
def StealerPaquets():

    return render_template("StealerPaquets.html")

    
# Nueva ruta para mostrar los detalles de un grupo especÃ­fico
@app.route('/groups/<group_name>')
def group_detail(group_name):
    try:
        with open("groups.json", "r") as f:
            groups_data = json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        groups_data = []

    # Encontrar el grupo con el nombre dado
    group = next((g for g in groups_data if g["name"].lower() == group_name.lower()), None)

    if not group:
        return "Group not found", 404

        # Convertir los cÃ³digos de paÃ­s a emojis de bandera
    for item in group.get("targets", []):
        
        item['discovered'] = datetime.strptime(item['discovered'], '%Y-%m-%d %H:%M:%S.%f')   

        country_code = item["country"]
        if country_code:
            item["country_flag"] = country_flags.get(country_code, '')  # Usa el diccionario para obtener la bandera
        else:
            item["country_flag"] = ''

    
    country_filter = request.args.get('country-filter', '')
    discovered_order = request.args.get('discovered-order', 'desc')  # por defecto descendente

    # Filtrar los datos
    filtered_data = group.get("targets", [])
    if country_filter:
        filtered_data = [item for item in filtered_data if item['country'] == country_filter]

    # Ordenar los datos
    if discovered_order == 'asc':
        filtered_data.sort(key=lambda x: x['discovered'])
    else:
        filtered_data.sort(key=lambda x: x['discovered'], reverse=True)

    countries = sorted(set(item['country'] for item in group.get("targets", [])))

    # Pasar el grupo encontrado a la plantilla
    return render_template("group_detail.html", group=group, data=filtered_data, get_country_name=get_country_name, countries=countries)

@app.route('/your_view_function')
def your_view_function():
    group_filter = request.args.get('group-filter', '')
    country_filter = request.args.get('country-filter', '')
    discovered_order = request.args.get('discovered-order', 'desc')  # por defecto descendente

    # Filtrar los datos
    filtered_data = data
    if group_filter:
        filtered_data = [item for item in filtered_data if item['group_name'] == group_filter]
    if country_filter:
        filtered_data = [item for item in filtered_data if item['country'] == country_filter]

    # Ordenar los datos
    if discovered_order == 'asc':
        filtered_data.sort(key=lambda x: x['discovered'])
    else:
        filtered_data.sort(key=lambda x: x['discovered'], reverse=True)

    # Obtener listas Ãºnicas de grupos y paÃ­ses para los dropdowns
    groups = sorted(set(item['group_name'] for item in data))
    countries = sorted(set(item['country'] for item in data))

    return render_template('your_template.html', data=filtered_data, groups=groups, countries=countries)



if __name__ == '__main__':
    # Start the data fetching in a separate thread
    threading.Thread(target=schedule_data_fetching, daemon=True).start()
    #app.run(debug=True)
    app.run(host='0.0.0.0', port=5000)

